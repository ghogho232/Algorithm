# [Gold I] 냅색문제 - 1450 

[문제 링크](https://www.acmicpc.net/problem/1450) 

### 성능 요약

메모리: 65732 KB, 시간: 44 ms

### 분류

이분 탐색, 중간에서 만나기

### 문제 설명

<p>세준이는 N개의 물건을 가지고 있고, 최대 C만큼의 무게를 넣을 수 있는 가방을 하나 가지고 있다.</p>

<p>N개의 물건을 가방에 넣는 방법의 수를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 N과 C가 주어진다. N은 30보다 작거나 같은 자연수, C는 10<sup>9</sup>보다 작거나 같은 음이 아닌 정수이다. 둘째 줄에 물건의 무게가 주어진다. 무게도 10<sup>9</sup>보다 작거나 같은 자연수이다.</p>

### 출력 

 <p>첫째 줄에 가방에 넣는 방법의 수를 출력한다.</p>
 
 vector<ll> arr; 및 vector<ll> v1, v2;:

세 개의 벡터를 선언합니다. arr은 입력 숫자를 저장하는 벡터이고, v1 및 v2는 부분 합을 저장하는 데 사용될 벡터입니다.
void recursion(int l, int r, vector<long long>&v, long long sum):

재귀 함수 recursion을 정의합니다. 이 함수는 부분 합을 계산하는 데 사용됩니다.
l 및 r은 현재 고려 중인 배열의 부분 집합을 나타내는 인덱스 범위입니다.
v는 계산된 부분 합을 저장하는 벡터로, 참조로 전달됩니다.
sum은 현재까지 부분 집합의 합을 나타냅니다.
if (l > r):

재귀 함수의 종료 조건입니다. l이 r보다 크다면 현재 부분 집합이 비어 있으므로, sum을 v 벡터에 추가하고 함수를 종료합니다.
재귀 호출:

recursion(l + 1, r, v, sum) 및 recursion(l + 1, r, v, sum + arr[l])을 통해 재귀 호출을 수행합니다. 이렇게 하면 현재 인덱스 l에 해당하는 원소를 부분 집합에 포함하거나 포함하지 않고 모든 가능한 부분 합을 계산할 수 있습니다.

부분 합 계산과 루프:

for(int i=0; i<v1.size(); i++) 루프에서 왼쪽 절반의 부분 합 v1[i]에 대해 다음을 수행합니다:
upper_bound(v2.begin(), v2.end(), c - v1[i])를 사용하여 v2 벡터에서 c - v1[i]보다 큰 값을 가진 원소의 위치를 찾습니다.
v2.begin()을 빼면 해당 원소의 인덱스가 됩니다.
찾은 위치를 v2에서 빼기 위해 - v2.begin()을 수행하고, 그 결과를 ans에 더합니다.
이 과정을 통해 왼쪽 절반과 오른쪽 절반의 모든 가능한 조합에 대한 부분 합을 계산하고, 그 중에서 c와 같은 값을 가지는 경우의 수를 구합니다.
